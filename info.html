<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cognitive Distortions Matching Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }

        .card {
            cursor: pointer;
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out, background-color 0.3s;
            border-width: 2px;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }

        .card.selected {
            border-color: #3b82f6; /* blue-500 */
            transform: scale(1.03);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.4);
        }

        .card.correct {
            background-color: #dcfce7; /* green-100 */
            border-color: #22c55e; /* green-500 */
            color: #15803d; /* green-800 */
            cursor: not-allowed;
            animation: none;
            transform: none;
            box-shadow: none;
        }
        
        .card.correct:hover {
            transform: none;
        }

        .card.incorrect {
            background-color: #fee2e2; /* red-100 */
            border-color: #ef4444; /* red-500 */
            animation: shake 0.5s ease-in-out;
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        #feedback-message {
            transition: opacity 0.3s ease-in-out;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 min-h-screen flex items-center justify-center p-4">

    <main class="bg-white rounded-xl shadow-2xl p-6 md:p-10 w-full max-w-6xl mx-auto">
        <!-- Header Section -->
        <div class="text-center mb-8">
            <h1 class="text-3xl md:text-4xl font-bold text-gray-900">Cognitive Distortions</h1>
            <h2 class="text-xl md:text-2xl font-semibold text-blue-600">Matching Challenge!</h2>
            <p class="mt-2 text-gray-600 max-w-2xl mx-auto">Click a term on the left, then click its matching definition on the right. Good luck!</p>
        </div>

        <!-- Game Info Bar -->
        <div class="flex justify-between items-center mb-6 bg-gray-50 p-4 rounded-lg">
            <div id="progress-counter" class="text-lg font-semibold text-gray-700">Pairs Found: 0 / 12</div>
            <div id="feedback-message" class="text-lg font-bold text-center h-6 flex-grow"></div>
            <button id="reset-button" class="bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700 transition-colors duration-300 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50">
                Reset Game
            </button>
        </div>
        
        <!-- Main Game Board -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 md:gap-8">
            <!-- Column for Distortion Terms -->
            <div id="terms-container" class="space-y-4">
                <!-- Term cards will be generated here by JavaScript -->
            </div>
            <!-- Column for Definitions -->
            <div id="definitions-container" class="space-y-4">
                <!-- Definition cards will be generated here by JavaScript -->
            </div>
        </div>

    </main>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const distortions = [
                { id: 1, term: 'Magnification & Minimisation', definition: 'Exaggerating or minimising the importance of events. Believing your own achievements are unimportant, or that your mistakes are excessively important.' },
                { id: 2, term: 'Catastrophising', definition: 'Seeing only the worst possible outcomes of a situation.' },
                { id: 3, term: 'Overgeneralisation', definition: 'Making broad interpretations from a single or few events. e.g., "I felt awkward during my job interview. I am always so awkward."' },
                { id: 4, term: 'Magical Thinking', definition: 'The belief that your acts will influence unrelated situations. e.g., "I am a good personâ€”bad things shouldn\'t happen to me."' },
                { id: 5, term: 'Personalisation', definition: 'The belief that you are responsible for events outside of your own control. e.g., "My mum is always upset. She would be fine if I did more to help her."' },
                { id: 6, term: 'Jumping to Conclusions', definition: 'Interpreting the meaning of a situation with little or no evidence.' },
                { id: 7, term: 'Mind Reading', definition: 'Interpreting the thoughts and beliefs of others without adequate evidence. e.g., "She probably thinks I\'m ugly."' },
                { id: 8, term: 'Fortune Telling', definition: 'The expectation that a situation will turn out badly without adequate evidence.' },
                { id: 9, term: 'Emotional Reasoning', definition: 'The assumption that your emotions reflect the way things really are. e.g., "I feel like a bad friend, therefore I must be a bad friend."' },
                { id: 10, term: 'Disqualifying the Positive', definition: 'Recognising only the negative aspects of a situation while ignoring the positive. Focusing on a single piece of negative feedback.' },
                { id: 11, term: '"Should" Statements', definition: 'The belief that things should be a certain way. e.g., "I should always be friendly."' },
                { id: 12, term: 'All-or-Nothing Thinking', definition: 'Thinking in absolutes such as "always", "never", or "every". e.g., "I never do a good enough job on anything."' }
            ];

            const termsContainer = document.getElementById('terms-container');
            const definitionsContainer = document.getElementById('definitions-container');
            const progressCounter = document.getElementById('progress-counter');
            const feedbackMessage = document.getElementById('feedback-message');
            const resetButton = document.getElementById('reset-button');
            
            let selectedTerm = null;
            let selectedDefinition = null;
            let correctMatches = 0;
            const totalPairs = distortions.length;

            // Utility function to shuffle an array
            function shuffle(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }

            function createCard(item, type) {
                const card = document.createElement('div');
                card.classList.add('card', 'p-4', 'bg-white', 'rounded-lg', 'border-gray-200', 'shadow-sm', 'min-h-[80px]', 'flex', 'items-center', 'justify-center', 'text-center');
                card.dataset.id = item.id;
                card.dataset.type = type;
                card.textContent = type === 'term' ? item.term : item.definition;
                card.addEventListener('click', handleCardClick);
                return card;
            }

            function initGame() {
                // Clear existing cards and reset state
                termsContainer.innerHTML = '';
                definitionsContainer.innerHTML = '';
                selectedTerm = null;
                selectedDefinition = null;
                correctMatches = 0;
                
                // Shuffle terms and definitions separately
                const shuffledTerms = shuffle([...distortions]);
                const shuffledDefinitions = shuffle([...distortions]);

                // Populate containers with new cards
                shuffledTerms.forEach(item => termsContainer.appendChild(createCard(item, 'term')));
                shuffledDefinitions.forEach(item => definitionsContainer.appendChild(createCard(item, 'definition')));

                updateProgress();
                showFeedback('');
            }

            function handleCardClick(event) {
                const clickedCard = event.currentTarget;
                if (clickedCard.classList.contains('correct')) {
                    return; // Ignore clicks on already matched cards
                }

                const cardType = clickedCard.dataset.type;
                
                // Deselect if clicking the same card again
                if ((cardType === 'term' && clickedCard === selectedTerm) || (cardType === 'definition' && clickedCard === selectedDefinition)) {
                    clickedCard.classList.remove('selected');
                    if (cardType === 'term') selectedTerm = null;
                    else selectedDefinition = null;
                    return;
                }

                if (cardType === 'term') {
                    if (selectedTerm) selectedTerm.classList.remove('selected');
                    selectedTerm = clickedCard;
                    selectedTerm.classList.add('selected');
                } else if (cardType === 'definition') {
                    if (selectedDefinition) selectedDefinition.classList.remove('selected');
                    selectedDefinition = clickedCard;
                    selectedDefinition.classList.add('selected');
                }

                if (selectedTerm && selectedDefinition) {
                    checkMatch();
                }
            }

            function checkMatch() {
                const termId = selectedTerm.dataset.id;
                const defId = selectedDefinition.dataset.id;

                if (termId === defId) {
                    // Correct Match
                    showFeedback('Correct!', 'green');
                    selectedTerm.classList.remove('selected');
                    selectedDefinition.classList.remove('selected');
                    selectedTerm.classList.add('correct');
                    selectedDefinition.classList.add('correct');
                    correctMatches++;
                    updateProgress();
                    
                    // Clear selections
                    selectedTerm = null;
                    selectedDefinition = null;
                    
                    if (correctMatches === totalPairs) {
                        showFeedback('Congratulations! You found them all!', 'blue');
                    }

                } else {
                    // Incorrect Match
                    showFeedback('Not quite, try again!', 'red');
                    selectedTerm.classList.add('incorrect');
                    selectedDefinition.classList.add('incorrect');

                    // Temporarily disable clicks while showing incorrect feedback
                    termsContainer.style.pointerEvents = 'none';
                    definitionsContainer.style.pointerEvents = 'none';

                    setTimeout(() => {
                        selectedTerm.classList.remove('selected', 'incorrect');
                        selectedDefinition.classList.remove('selected', 'incorrect');
                        selectedTerm = null;
                        selectedDefinition = null;
                        showFeedback('');
                        termsContainer.style.pointerEvents = 'auto';
                        definitionsContainer.style.pointerEvents = 'auto';
                    }, 1000);
                }
            }
            
            function updateProgress() {
                progressCounter.textContent = `Pairs Found: ${correctMatches} / ${totalPairs}`;
            }

            function showFeedback(message, color = 'gray') {
                feedbackMessage.textContent = message;
                feedbackMessage.style.color = color;
                feedbackMessage.style.opacity = '1';
                if (!message) {
                    feedbackMessage.style.opacity = '0';
                }
            }

            resetButton.addEventListener('click', initGame);

            // Initial game setup
            initGame();
        });
    </script>
</body>
</html>
